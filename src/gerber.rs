//! Serializes geometry to gerber files.

use crate::InnerAtom;
use conv::TryFrom;
use geo::{MultiPolygon, Point};
use gerber_types::*;

use std::collections::HashMap;

const VERSION: &'static str = env!("CARGO_PKG_VERSION");

fn gerber_prelude<'a>(
    cf: CoordinateFormat,
    ff: FileFunction,
    apertures: impl Iterator<Item = &'a (i32, f64)>,
) -> Vec<Command> {
    let mut commands =
        vec![
            FunctionCode::GCode(GCode::Comment("Autogenerated Maker Panel".to_string())).into(),
            ExtendedCode::CoordinateFormat(cf).into(),
            ExtendedCode::Unit(Unit::Millimeters).into(),
            ExtendedCode::FileAttribute(FileAttribute::GenerationSoftware(
                GenerationSoftware::new("Maker Panel", "maker-panel", Some(VERSION)),
            ))
            .into(),
            ExtendedCode::FileAttribute(FileAttribute::Part(Part::Single)).into(),
            ExtendedCode::FileAttribute(FileAttribute::FileFunction(ff)).into(),
            ExtendedCode::LoadPolarity(Polarity::Dark).into(),
            FunctionCode::GCode(GCode::InterpolationMode(InterpolationMode::Linear)).into(),
        ];

    for (code, diameter) in apertures {
        commands.push(
            ExtendedCode::ApertureDefinition(ApertureDefinition {
                code: *code,
                aperture: Aperture::Circle(Circle {
                    diameter: *diameter,
                    hole_diameter: None,
                }),
            })
            .into(),
        );
    }

    commands
}

/// Serializes a representation of edge geometry in extender gerber format.
pub fn serialize_edge(edges: MultiPolygon<f64>) -> Result<Vec<Command>, ()> {
    let cf = CoordinateFormat::new(4, 6);
    let mut commands = gerber_prelude(
        cf,
        FileFunction::Profile(Profile::NonPlated),
        [(10, 0.01)].iter(),
    );
    commands.push(FunctionCode::DCode(DCode::SelectAperture(10)).into());

    for poly in edges {
        let mut last: Option<Point<f64>> = None;
        for point in poly.exterior().points_iter() {
            if let Some(cmd) = match last {
                None => FunctionCode::DCode(DCode::Operation(Operation::Move(Coordinates::new(
                    CoordinateNumber::try_from(point.x()).unwrap(),
                    CoordinateNumber::try_from(point.y()).unwrap(),
                    cf,
                ))))
                .into(),

                Some(last) => {
                    let x = CoordinateNumber::try_from(point.x()).unwrap();
                    let y = CoordinateNumber::try_from(point.y()).unwrap();

                    match (
                        ((last.x() - point.x()).abs() < 1.0E-6),
                        ((last.y() - point.y()).abs() < 1.0E-6),
                    ) {
                        (true, true) => None,
                        (_, true) => Some(
                            FunctionCode::DCode(DCode::Operation(Operation::Interpolate(
                                Coordinates::at_y(y, cf),
                                None,
                            )))
                            .into(),
                        ),
                        (true, _) => Some(
                            FunctionCode::DCode(DCode::Operation(Operation::Interpolate(
                                Coordinates::at_x(x, cf),
                                None,
                            )))
                            .into(),
                        ),
                        (_, _) => Some(
                            FunctionCode::DCode(DCode::Operation(Operation::Interpolate(
                                Coordinates::new(x, y, cf),
                                None,
                            )))
                            .into(),
                        ),
                    }
                }
            } {
                commands.push(gerber_types::Command::FunctionCode(cmd));
            }

            last = Some(point.clone());
        }
    }

    commands.push(FunctionCode::MCode(MCode::EndOfFile).into());
    Ok(commands)
}

#[derive(Debug, Copy, Clone)]
struct FloatBits(f64);

impl FloatBits {
    fn key(&self) -> u64 {
        unsafe { std::mem::transmute(self.0) }
    }
}

impl std::hash::Hash for FloatBits {
    fn hash<H>(&self, state: &mut H)
    where
        H: std::hash::Hasher,
    {
        self.key().hash(state)
    }
}

impl PartialEq for FloatBits {
    fn eq(&self, other: &FloatBits) -> bool {
        self.key() == other.key()
    }
}

impl Eq for FloatBits {}

/// Serializes a representation of copper/mask features in extender gerber format.
pub fn serialize_layer(
    out_layer: super::Layer,
    features: Vec<InnerAtom>,
) -> Result<Vec<Command>, ()> {
    let cf = CoordinateFormat::new(4, 6);

    // Collect all unique diameters to setup as apertures.
    let mut dias = HashMap::new();
    for feature in &features {
        match feature {
            InnerAtom::Circle { radius, layer, .. } => {
                if out_layer == *layer {
                    dias.insert(FloatBits(*radius * 2.0), ());
                }
            }
            InnerAtom::Drill { .. } => (), // Drill hits are not on gerbers
                                           // InnerAtom::Drill { radius, layer, .. } => if out_layer == *layer {
                                           //     dias.insert(FloatBits(*radius * 2.0), ());
                                           // }
        }
    }
    let dias: Vec<_> = dias
        .keys()
        .map(|fb| fb.0)
        .enumerate()
        .map(|(i, f)| (10 + i as i32, f))
        .collect();

    let mut commands = gerber_prelude(
        cf,
        match out_layer {
            super::Layer::FrontCopper => FileFunction::Copper {
                layer: 1,
                pos: ExtendedPosition::Top,
                copper_type: None,
            },
            super::Layer::BackCopper => FileFunction::Copper {
                layer: 2,
                pos: ExtendedPosition::Bottom,
                copper_type: None,
            },
            super::Layer::FrontMask => FileFunction::Soldermask {
                pos: Position::Top,
                index: None,
            },
            super::Layer::BackMask => FileFunction::Soldermask {
                pos: Position::Bottom,
                index: None,
            },
            _ => {
                return Err(());
            }
        },
        dias.iter(),
    );

    let mut last_aperture: Option<i32> = None;
    for feature in &features {
        match feature {
            InnerAtom::Circle {
                center,
                radius,
                layer,
                ..
            } => {
                if out_layer == *layer {
                    let code = dias.iter().find(|&(_, f)| *f == (*radius * 2.0)).unwrap().0;
                    if last_aperture != Some(code) {
                        commands.push(FunctionCode::DCode(DCode::SelectAperture(code)).into());
                        last_aperture = Some(code);
                    }

                    let x = CoordinateNumber::try_from(center.x).unwrap();
                    let y = CoordinateNumber::try_from(center.y).unwrap();
                    commands.push(gerber_types::Command::FunctionCode(
                        FunctionCode::DCode(DCode::Operation(Operation::Flash(Coordinates::new(
                            x, y, cf,
                        ))))
                        .into(),
                    ));
                }
            }
            InnerAtom::Drill { .. } => (), // Drill hits are not on gerbers
        }
    }

    commands.push(FunctionCode::MCode(MCode::EndOfFile).into());
    Ok(commands)
}
