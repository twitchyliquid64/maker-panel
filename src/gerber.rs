//! Serializes geometry to gerber files.

use conv::TryFrom;
use geo::{MultiPolygon, Point};
use gerber_types::*;

const VERSION: &'static str = env!("CARGO_PKG_VERSION");

/// Serializes a representation of edge geometry in extender gerber format.
pub fn serialize_edge(edges: MultiPolygon<f64>) -> Result<Vec<Command>, ()> {
    let cf = CoordinateFormat::new(4, 6);
    let mut commands: Vec<Command> =
        vec![
            FunctionCode::GCode(GCode::Comment("Autogenerated Maker Panel".to_string())).into(),
            ExtendedCode::CoordinateFormat(cf).into(),
            ExtendedCode::Unit(Unit::Millimeters).into(),
            ExtendedCode::FileAttribute(FileAttribute::GenerationSoftware(
                GenerationSoftware::new("Maker Panel", "maker-panel", Some(VERSION)),
            ))
            .into(),
            ExtendedCode::FileAttribute(FileAttribute::Part(Part::Other("Edge Cuts".to_string())))
                .into(),
            ExtendedCode::LoadPolarity(Polarity::Dark).into(),
            FunctionCode::GCode(GCode::InterpolationMode(InterpolationMode::Linear)).into(),
            ExtendedCode::ApertureDefinition(ApertureDefinition {
                code: 10,
                aperture: Aperture::Circle(Circle {
                    diameter: 0.01,
                    hole_diameter: None,
                }),
            })
            .into(),
            FunctionCode::DCode(DCode::SelectAperture(10)).into(),
        ];

    for poly in edges {
        let mut last: Option<Point<f64>> = None;
        for point in poly.exterior().points_iter() {
            if let Some(cmd) = match last {
                None => FunctionCode::DCode(DCode::Operation(Operation::Move(Coordinates::new(
                    CoordinateNumber::try_from(point.x()).unwrap(),
                    CoordinateNumber::try_from(point.y()).unwrap(),
                    cf,
                ))))
                .into(),

                Some(last) => {
                    let x = CoordinateNumber::try_from(point.x()).unwrap();
                    let y = CoordinateNumber::try_from(point.y()).unwrap();

                    match (
                        ((last.x() - point.x()).abs() < 1.0E-6),
                        ((last.y() - point.y()).abs() < 1.0E-6),
                    ) {
                        (true, true) => None,
                        (_, true) => Some(
                            FunctionCode::DCode(DCode::Operation(Operation::Interpolate(
                                Coordinates::at_y(y, cf),
                                None,
                            )))
                            .into(),
                        ),
                        (true, _) => Some(
                            FunctionCode::DCode(DCode::Operation(Operation::Interpolate(
                                Coordinates::at_x(x, cf),
                                None,
                            )))
                            .into(),
                        ),
                        (_, _) => Some(
                            FunctionCode::DCode(DCode::Operation(Operation::Interpolate(
                                Coordinates::new(x, y, cf),
                                None,
                            )))
                            .into(),
                        ),
                    }
                }
            } {
                commands.push(gerber_types::Command::FunctionCode(cmd));
            }

            last = Some(point.clone());
        }
    }

    commands.push(FunctionCode::MCode(MCode::EndOfFile).into());
    Ok(commands)
}
