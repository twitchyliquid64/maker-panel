<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>maker-panel playground</title>

    <style>
      #err, textarea {
        font-family:Consolas,Monaco,Lucida Console,Liberation Mono,DejaVu Sans Mono,Bitstream Vera Sans Mono,Courier New, monospace;
      }

      #err {
        margin-left: 6px;
      }

      .row {
        display: flex;
        flex-direction: row;
        flex-wrap: wrap;
        width: 100%;
        margin-top: 12px;
      }

      .column {
        display: flex;
        flex-direction: column;
        flex-basis: 100%;
        flex: 1;
      }

      textarea {
        height: 25em;
      }

      #render {
        height: 100%;
      }
    </style>

    <script src="./deps/svg.js"></script>
    <script src="./deps/svg.draggy.js"></script>
    <script src="./deps/svg.pan-zoom.js"></script>

  </head>
  <body>
    <div>
      <h2>maker-panel playground</h2>
      <p>
        <a href="https://github.com/twitchyliquid64/maker-panel/blob/main/docs/spec-reference.md">[Reference]</a> |
        <a href="https://github.com/twitchyliquid64/maker-panel">[Github]</a>
        <span id="loading">Backend loading, please wait.</span>
      </p>

      <div class='row'>
        <div class='column' style="flex: 2;">
          <textarea id="code"></textarea>
        </div>
        <div class='column'>
          <span id="err"></span>
          <div id="render"></div>
        </div>
      </div>

    </div>

    <script type="module">
      import init, {check_parse_err, maker_panel_version, render} from "./pkg/maker_panel_wasm.js";
      init()
        .then(() => {
          // Remove the loading message.
          document.getElementById('loading').innerText = " maker panel v" + maker_panel_version();

          const code = document.getElementById('code');
          const err = document.getElementById('err');
          const out = document.getElementById('render');
          var svg = new SVG(out);
          var pz = null;

          code.addEventListener('input', function() {
            var c = code.value;
            // Check the syntax and print any errors if maker-panel expressions
            // are typed.
            if (c != "") {
              var parse_result = check_parse_err(code.value);
              if (!parse_result) {
                err.innerText = "âœ“ Panel valid";
              } else {
                if (parse_result.Parse) {
                  err.innerText = "Syntax invalid:\n" + parse_result.Parse;
                } else if (parse_result.UndefinedVariable) {
                  err.innerText = "Undefined variable: " + parse_result.UndefinedVariable;
                } else if (parse_result.BadType) {
                  err.innerText = "Bad type: " + parse_result.BadType;
                }
              }
            } else {
              err.innerText = "";
            }

          }, false);

          function to_color(c) {
            switch (c) {
            case "FrontCopper":
              return "#840000"
            case "FrontMask":
              return "#840084"
            case "FrontLegend":
              return "#00cede"
            case "BackCopper":
              return "#008400"
            case "BackMask":
              return "#840084"
            case "BackLegend":
              return "#040084"
            case "FabricationInstructions":
              return "#666666"
            default:
              return "#252525"
            }
          }

          function handle_hotkeys(e) {
            if (e.ctrlKey && e.key === 'r') {
              let previous_pan = (pz || {transform: null}).transform;
              let r = render(code.value);
              console.log(r);

              svg.clear();
              var links = svg.group();
              var markers = svg.group();
              var nodes = svg.group();

              // Create the geometry.
              var polygon = nodes.group().polygon(r.outer).fill('none').stroke({ width: 0.2 });
              var bbox = polygon.bbox();
              for (var i = 0; i < r.inners.length; i++) {
                nodes.group().polygon(r.inners[i]).fill('none').stroke({ width: 0.15 });
              }

              // Create the surface features.
              for (var i = 0; i < r.surface_features.length; i++) {
                const f = r.surface_features[i];
                if (f.Circle) {
                  nodes.group().circle(f.Circle.radius * 2)
                    .center(f.Circle.center[0], f.Circle.center[1])
                    .fill(to_color(f.Circle.layer)).stroke('none');
                }
                if (f.Drill) {
                  nodes.group().circle(f.Drill.radius * 2)
                    .center(f.Drill.center[0], f.Drill.center[1])
                    .fill(to_color('#252525')).stroke('none');
                }
              }


              // Make the group pannable and zoomable, set starting position.
              pz = nodes.panZoom();
              if (previous_pan)
                pz.setPosition(previous_pan.x, previous_pan.y, previous_pan.scaleX);
              else
                pz.setPosition(50-bbox.x, 50-bbox.y, 2);

              e.preventDefault();
            };
          }
          code.onkeydown = handle_hotkeys;

        });
    </script>
  </body>
</html>
